/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/v1/orders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a new order. In order to replace an existing order with a new one, the appData must contain a [valid replacement order UID](https://github.com/cowprotocol/app-data/blob/main/src/schemas/v1.1.0.json#L62), then the indicated order is cancelled, and a new one placed.
         *     This allows an old order to be cancelled AND a new order to be created in an atomic operation with a single signature.
         *     This may be useful for replacing orders when on-chain prices move outside of the original order's limit price. */
        post: operations["createOrder"];
        /**
         * Cancel multiple orders by marking them invalid with a timestamp.
         * @description This is a *best effort* cancellation, and might not prevent solvers from settling the orders (if the order is part of an in-flight settlement transaction for example). Authentication must be provided by an [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature of an `OrderCancellations(bytes[] orderUids)` message.
         *
         */
        delete: operations["cancelOrders"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/orders/{UID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get existing order from UID. */
        get: operations["getOrder"];
        put?: never;
        post?: never;
        /**
         * Cancel an order by marking it invalid with a timestamp.
         * @deprecated
         * @description The successful deletion might not prevent solvers from settling the
         *     order.
         *
         *     Authentication must be provided by providing an
         *     [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature of an
         *     `OrderCancellation(bytes orderUid)` message.
         */
        delete: operations["cancelOrder"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/orders/{UID}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the status of an order. */
        get: operations["getOrderStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/transactions/{txHash}/orders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get orders by settlement transaction hash. */
        get: operations["getOrdersByTxHash"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/trades": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get existing trades (unpaginated).
         * @deprecated
         * @description **Deprecated:** This endpoint is deprecated and will be removed in the future. Please use `/api/v2/trades` instead, which provides pagination support.
         *
         *     Exactly one of `owner` or `orderUid` must be set.
         *
         *     Results are sorted by block number and log index descending (newest trades first).
         *
         *     **Note:** This endpoint returns all matching trades without pagination. For paginated results, use `/api/v2/trades`.
         *
         */
        get: operations["getTrades"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/trades": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get existing trades (paginated).
         * @description Exactly one of `owner` or `orderUid` must be set.
         *
         *     Results are paginated and sorted by block number and log index descending (newest trades first).
         *
         *     To enumerate all trades start with `offset` 0 and keep increasing the
         *     `offset` by the total number of returned results. When a response
         *     contains less than `limit` the last page has been reached.
         *
         */
        get: operations["getTradesV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auction": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the current batch auction.
         * @description The current batch auction that solvers should be solving right now. This
         *     includes:
         *
         *     * A list of solvable orders. * The block on which the batch was created.
         *     * Prices for all tokens being traded (used for objective value
         *     computation).
         *
         *     **Note: This endpoint is currently permissioned. Reach out in discord if
         *     you need access.**
         */
        get: operations["getCurrentBatchAuction"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/account/{owner}/orders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get orders of one user paginated.
         * @description The orders are sorted by their creation date descending (newest orders
         *     first).
         *
         *     To enumerate all orders start with `offset` 0 and keep increasing the
         *     `offset` by the total number of returned results. When a response
         *     contains less than `limit` the last page has been reached.
         */
        get: operations["getUserOrdersPaginated"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/token/{token}/native_price": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get native price for the given token.
         * @description Price is the exchange rate between the specified token and the network's
         *     native currency.
         *
         *     It represents the amount of native token atoms needed to buy 1 atom of
         *     the specified token.
         */
        get: operations["getTokenNativePrice"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/quote": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Quote a price and fee for the specified order parameters.
         * @description Given a partial order compute the minimum fee and a price estimate for the order. Return a full order that can be used directly for signing, and with an included signature, passed directly to the order creation endpoint.
         *
         */
        post: operations["quote"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/solver_competition/{auction_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about a solver competition.
         * @deprecated
         * @description Returns the competition information by `auction_id`.
         *
         */
        get: operations["getSolverCompetitionByAuctionId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/solver_competition/by_tx_hash/{tx_hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about solver competition.
         * @deprecated
         * @description Returns the competition information by `tx_hash`.
         *
         */
        get: operations["getSolverCompetitionByTxHash"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/solver_competition/latest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about the most recent solver competition.
         * @deprecated
         * @description Returns the competition information for the last seen auction_id.
         *
         */
        get: operations["getSolverCompetitionLatest"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/solver_competition/{auction_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about a solver competition.
         * @description Returns the competition information by `auction_id`.
         *
         */
        get: operations["getSolverCompetitionByAuctionIdV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/solver_competition/by_tx_hash/{tx_hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about solver competition.
         * @description Returns the competition information by `tx_hash`.
         *
         */
        get: operations["getSolverCompetitionByTxHashV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v2/solver_competition/latest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get information about the most recent solver competition.
         * @description Returns the competition information for the last seen auction_id.
         *
         */
        get: operations["getSolverCompetitionLatestV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the API's current deployed version.
         * @description Returns the git commit hash, branch name and release tag (code: https://github.com/cowprotocol/services).
         *
         */
        get: operations["getApiVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/app_data/{app_data_hash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the full `appData` from contract `appDataHash`. */
        get: operations["getAppDataByHash"];
        /**
         * Registers a full `appData` so it can be referenced by `appDataHash`.
         * @description Uploads a full `appData` to orderbook so that orders created with the corresponding `appDataHash` can be linked to the original full `appData`.
         *
         */
        put: operations["registerAppDataByHash"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/app_data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Registers a full `appData` and returns `appDataHash`.
         * @description Uploads a full `appData` to orderbook and returns the corresponding `appDataHash`.
         *
         */
        put: operations["registerAppData"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/users/{address}/total_surplus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the total surplus earned by the user. [UNSTABLE]
         * @description ### Caution
         *
         *     This endpoint is under active development and should NOT be considered
         *     stable.
         */
        get: operations["getAddressTotalSurplus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description 32 byte digest encoded as a hex with `0x` prefix.
         * @example 0xd51f28edffcaaa76be4a22f6375ad289272c037f3cc072345676e88d92ced8b5
         */
        TransactionHash: string;
        /**
         * @description 20 byte Ethereum address encoded as a hex with `0x` prefix.
         * @example 0x6810e776880c02933d47db1b9fc05908e5386b96
         */
        Address: string;
        /**
         * @description The string encoding of a JSON object representing some `appData`. The
         *     format of the JSON expected in the `appData` field is defined
         *     [here](https://github.com/cowprotocol/app-data).
         *
         * @example {"version":"0.9.0","metadata":{}}
         */
        AppData: string;
        /**
         * @description 32 bytes encoded as hex with `0x` prefix.
         *     It's expected to be the hash of the stringified JSON object representing the `appData`.
         *
         * @example 0x0000000000000000000000000000000000000000000000000000000000000000
         */
        AppDataHash: string;
        /** @description An `appData` document that is registered with the API. */
        AppDataObject: {
            fullAppData?: components["schemas"]["AppData"];
        };
        /**
         * @description A big unsigned integer encoded in decimal.
         * @example 1234567890
         */
        BigUint: string;
        /**
         * @description Some `calldata` sent to a contract in a transaction encoded as a hex with `0x` prefix.
         * @example 0xca11da7a
         */
        CallData: string;
        /**
         * @description Amount of a token. `uint256` encoded in decimal.
         * @example 1234567890
         */
        TokenAmount: string;
        OnchainOrderData: {
            /** @description If orders are placed as on-chain orders, the owner of the order might be a smart contract, but not the user placing the order. The actual user will be provided in this field.
             *      */
            sender: components["schemas"]["Address"];
            /**
             * @description Describes the error, if the order placement was not successful. This could happen, for example, if the `validTo` is too high, or no valid quote was found or generated.
             *
             * @enum {string}
             */
            placementError?: "QuoteNotFound" | "ValidToTooFarInFuture" | "PreValidationError";
        };
        /** @description Provides the additional data for ethflow orders. */
        EthflowData: {
            /** @description Specifies in which transaction the order was refunded. If
             *     this field is null the order was not yet refunded.
             *      */
            refundTxHash: components["schemas"]["TransactionHash"] | null;
            /** @description Describes the `validTo` of an order ethflow order.
             *
             *     **NOTE**: For ethflow orders, the `validTo` encoded in the smart
             *     contract is `type(uint256).max`.
             *      */
            userValidTo: number;
        };
        /**
         * @description Is this order a buy or sell?
         * @enum {string}
         */
        OrderKind: "buy" | "sell";
        /**
         * @description Order class.
         * @enum {string}
         */
        OrderClass: "market" | "limit" | "liquidity";
        /**
         * @description Where should the `sellToken` be drawn from?
         * @enum {string}
         */
        SellTokenSource: "erc20" | "internal" | "external";
        /**
         * @description Where should the `buyToken` be transferred to?
         * @enum {string}
         */
        BuyTokenDestination: "erc20" | "internal";
        /**
         * @description How good should the price estimate be?
         *
         *     Fast: The price estimate is chosen among the fastest N price estimates.
         *     Optimal: The price estimate is chosen among all price estimates.
         *     Verified: The price estimate is chosen among all verified/simulated
         *     price estimates.
         *
         *     **NOTE**: Orders are supposed to be created from `verified` or `optimal`
         *     price estimates.
         * @enum {string}
         */
        PriceQuality: "fast" | "optimal" | "verified";
        /**
         * @description The current order status.
         * @enum {string}
         */
        OrderStatus: "presignaturePending" | "open" | "fulfilled" | "cancelled" | "expired";
        /** @description Order parameters. */
        OrderParameters: {
            /** @description ERC-20 token to be sold. */
            sellToken: components["schemas"]["Address"];
            /** @description ERC-20 token to be bought. */
            buyToken: components["schemas"]["Address"];
            /** @description An optional Ethereum address to receive the proceeds of the trade instead of the owner (i.e. the order signer).
             *      */
            receiver?: components["schemas"]["Address"] | null;
            /** @description Amount of `sellToken` to be sold in atoms. */
            sellAmount: components["schemas"]["TokenAmount"];
            /** @description Amount of `buyToken` to be bought in atoms. */
            buyAmount: components["schemas"]["TokenAmount"];
            /** @description Unix timestamp (`uint32`) until which the order is valid. */
            validTo: number;
            /** @description The app data associated with the order. In quote responses, this can be either the full app data JSON string or the app data hash, depending on what was provided in the quote request.
             *      */
            appData: components["schemas"]["AppData"] | components["schemas"]["AppDataHash"];
            /** @description The hash of the app data. Only present when the full app data is also provided in the `appData` field.
             *      */
            appDataHash?: components["schemas"]["AppDataHash"];
            /** @description The fee amount in sell token atoms. For quote responses, this represents
             *     the estimated network fee, calculated as:
             *     `feeAmount = ceil((gasAmount * gasPrice) / sellTokenPrice)`.
             *
             *     When creating an order, this should be set to zero as fees are now
             *     computed dynamically by solvers.
             *      */
            feeAmount: components["schemas"]["TokenAmount"];
            /**
             * @description The estimated gas units required to execute the quoted trade.
             *
             * @example 150000
             */
            gasAmount: string;
            /**
             * @description The estimated gas price at the time of quoting, measured in Wei per gas unit.
             *
             * @example 15000000000
             */
            gasPrice: string;
            /**
             * @description Represents how much one atomic unit of the sell token is worth
             *     in the network's native token (in Wei or the equivalent atom).
             *
             * @example 0.0004
             */
            sellTokenPrice: string;
            /** @description The kind is either a buy or sell order. */
            kind: components["schemas"]["OrderKind"];
            /** @description Is the order fill-or-kill or partially fillable? */
            partiallyFillable: boolean;
            /**
             * @description Where the sell token should be drawn from. Defaults to `erc20` for standard ERC-20 token transfers.
             *
             * @default erc20
             */
            sellTokenBalance: components["schemas"]["SellTokenSource"];
            /**
             * @description Where the buy token should be transferred to. Defaults to `erc20` for standard ERC-20 token transfers.
             *
             * @default erc20
             */
            buyTokenBalance: components["schemas"]["BuyTokenDestination"];
            /**
             * @description The signing scheme to use for the order. Defaults to `eip712` for standard typed data signing.
             *
             * @default eip712
             */
            signingScheme: components["schemas"]["SigningScheme"];
        };
        /** @description Data a user provides when creating a new order. */
        OrderCreation: {
            /** @description see `OrderParameters::sellToken` */
            sellToken: components["schemas"]["Address"];
            /** @description see `OrderParameters::buyToken` */
            buyToken: components["schemas"]["Address"];
            /** @description see `OrderParameters::receiver` */
            receiver?: components["schemas"]["Address"] | null;
            /** @description see `OrderParameters::sellAmount` */
            sellAmount: components["schemas"]["TokenAmount"];
            /** @description see `OrderParameters::buyAmount` */
            buyAmount: components["schemas"]["TokenAmount"];
            /** @description see `OrderParameters::validTo` */
            validTo: number;
            /** @description see `OrderParameters::feeAmount` */
            feeAmount: components["schemas"]["TokenAmount"];
            /** @description see `OrderParameters::kind` */
            kind: components["schemas"]["OrderKind"];
            /** @description see `OrderParameters::partiallyFillable` */
            partiallyFillable: boolean;
            /**
             * @description see `OrderParameters::sellTokenBalance`
             * @default erc20
             */
            sellTokenBalance: components["schemas"]["SellTokenSource"];
            /**
             * @description see `OrderParameters::buyTokenBalance`
             * @default erc20
             */
            buyTokenBalance: components["schemas"]["BuyTokenDestination"];
            signingScheme: components["schemas"]["SigningScheme"];
            signature: components["schemas"]["Signature"];
            /** @description If set, the backend enforces that this address matches what is decoded as the *signer* of the signature. This helps catch errors with invalid signature encodings as the backend might otherwise silently work with an unexpected address that for example does not have any balance.
             *      */
            from?: components["schemas"]["Address"] | null;
            /** @description Orders can optionally include a quote ID. This way the order can be linked to a quote and enable providing more metadata when analysing order slippage.
             *      */
            quoteId?: number | null;
            /** @description This field comes in two forms for backward compatibility. The hash form will eventually stop being accepted.
             *      */
            appData: (string & components["schemas"]["AppData"]) | components["schemas"]["AppDataHash"];
            /** @description May be set for debugging purposes. If set, this field is compared to what the backend internally calculates as the app data hash based on the contents of `appData`. If the hash does not match, an error is returned. If this field is set, then `appData` **MUST** be a string encoding of a JSON object.
             *      */
            appDataHash?: components["schemas"]["AppDataHash"] | null;
        };
        /** @description Extra order data that is returned to users when querying orders but not provided by users when creating orders.
         *      */
        OrderMetaData: {
            /**
             * @description Creation time of the order. Encoded as ISO 8601 UTC.
             * @example 2020-12-03T18:35:18.814523Z
             */
            creationDate: string;
            /** @description The class of the order (market, limit, or liquidity). Determines how fees are handled.
             *      */
            class: components["schemas"]["OrderClass"];
            /** @description The address that signed the order and owns it. For regular orders, this is the trader. For EIP 1271 orders, it's the respective contract (see `onchainUser` for the actual trader).
             *      */
            owner: components["schemas"]["Address"];
            /** @description Unique identifier of the order. Computed as the EIP-712 hash of the order data combined with the owner address and valid_to timestamp.
             *      */
            uid: components["schemas"]["UID"];
            /**
             * @deprecated
             * @description Unused field that is currently always set to `null` and will be removed in the future.
             *
             */
            availableBalance?: components["schemas"]["TokenAmount"] | null;
            /** @description The total amount of `sellToken` that has been transferred from the user for this order so far.
             *      */
            executedSellAmount: components["schemas"]["BigUint"];
            /** @description The total amount of `sellToken` that has been transferred from the user for this order so far minus tokens that were transferred as part of the signed `fee` of the order. This is only relevant for old orders because now all orders have a signed `fee` of 0 and solvers compute an appropriate fee dynamically at the time of the order execution.
             *      */
            executedSellAmountBeforeFees: components["schemas"]["BigUint"];
            /** @description The total amount of `buyToken` that has been executed for this order.
             *      */
            executedBuyAmount: components["schemas"]["BigUint"];
            /** @description [DEPRECATED] The total amount of the user signed `fee` that have been executed for this order. This value is only non-negative for very old orders.
             *      */
            executedFeeAmount: components["schemas"]["BigUint"];
            /** @description Has this order been invalidated? */
            invalidated: boolean;
            /** @description Order status. */
            status: components["schemas"]["OrderStatus"];
            /** @description Liquidity orders are functionally the same as normal smart contract
             *     orders but are not placed with the intent of actively getting
             *     traded. Instead they facilitate the trade of normal orders by
             *     allowing them to be matched against liquidity orders which uses less
             *     gas and can have better prices than external liquidity.
             *
             *     As such liquidity orders will only be used in order to improve
             *     settlement of normal orders. They should not be expected to be
             *     traded otherwise and should not expect to get surplus. */
            isLiquidityOrder?: boolean;
            /** @description Additional data specific to ethflow orders. Only present for orders placed through the EthFlow contract, which allows trading native ETH directly without wrapping to WETH first.
             *      */
            ethflowData?: components["schemas"]["EthflowData"];
            /** @description This represents the actual trader of an on-chain order.
             *     ### ethflow orders
             *     In this case, the `owner` would be the `EthFlow` contract and *not* the actual trader.
             *      */
            onchainUser?: components["schemas"]["Address"];
            /** @description There is some data only available for orders that are placed on-chain. This data can be found in this object.
             *      */
            onchainOrderData?: components["schemas"]["OnchainOrderData"];
            /** @description Total fee charged for execution of the order. Contains network fee and protocol fees. This takes into account the historic static fee signed by the user and the new dynamic fee computed by solvers.
             *      */
            executedFee?: components["schemas"]["BigUint"];
            /** @description Token the executed fee was captured in. */
            executedFeeToken?: components["schemas"]["Address"];
            /** @description Full `appData`, which the contract-level `appData` is a hash of. See `OrderCreation` for more information.
             *      */
            fullAppData?: string | null;
            /** @description The address of the CoW Protocol settlement contract that this order is valid for. Orders are only valid on the settlement contract they were signed for.
             *      */
            settlementContract: components["schemas"]["Address"];
            /** @description If the order was created with a quote, this field contains the original quote data for reference. Includes gas estimation and pricing information captured at the time of quoting, which can be used to analyze order execution and calculate fees.
             *      */
            quote?: components["schemas"]["StoredOrderQuote"] | null;
        };
        /** @description An order as returned by the API. Combines the order creation data, order metadata, and any associated interactions.
         *      */
        Order: components["schemas"]["OrderCreation"] & components["schemas"]["OrderMetaData"] & {
            /** @description Optional pre and post interactions associated with the order. Pre-interactions are executed before the order's trade, and post-interactions are executed after.
             *      */
            interactions?: {
                /** @description Interactions to be executed before the order's trade. These can be used for setup operations like token approvals.
                 *      */
                pre?: components["schemas"]["InteractionData"][];
                /** @description Interactions to be executed after the order's trade. These can be used for cleanup or follow-up operations.
                 *      */
                post?: components["schemas"]["InteractionData"][];
            };
        };
        /** @description A solvable order included in the current batch auction. Contains the data forwarded to solvers for solving.
         *      */
        AuctionOrder: {
            uid: components["schemas"]["UID"];
            /** @description see `OrderParameters::sellToken` */
            sellToken: components["schemas"]["Address"];
            /** @description see `OrderParameters::buyToken` */
            buyToken: components["schemas"]["Address"];
            /** @description see `OrderParameters::sellAmount` */
            sellAmount: components["schemas"]["TokenAmount"];
            /** @description see `OrderParameters::buyAmount` */
            buyAmount: components["schemas"]["TokenAmount"];
            /**
             * @description Creation time of the order. Denominated in epoch seconds.
             * @example 123456
             */
            created: string;
            /** @description see `OrderParameters::validTo` */
            validTo: number;
            /** @description see `OrderParameters::kind` */
            kind: components["schemas"]["OrderKind"];
            /** @description see `OrderParameters::receiver` */
            receiver: components["schemas"]["Address"] | null;
            owner: components["schemas"]["Address"];
            /** @description see `OrderParameters::partiallyFillable` */
            partiallyFillable: boolean;
            /** @description Currently executed amount of sell/buy token, depending on the order kind.
             *      */
            executed: components["schemas"]["TokenAmount"];
            /** @description The pre-interactions that need to be executed before the first execution of the order.
             *      */
            preInteractions: components["schemas"]["InteractionData"][];
            /** @description The post-interactions that need to be executed after the execution of the order.
             *      */
            postInteractions: components["schemas"]["InteractionData"][];
            /**
             * @description see `OrderParameters::sellTokenBalance`
             * @default erc20
             */
            sellTokenBalance: components["schemas"]["SellTokenSource"];
            /**
             * @description see `OrderParameters::buyTokenBalance`
             * @default erc20
             */
            buyTokenBalance: components["schemas"]["BuyTokenDestination"];
            class: components["schemas"]["OrderClass"];
            appData: components["schemas"]["AppDataHash"];
            signature: components["schemas"]["Signature"];
            /** @description The fee policies that are used to compute the protocol fees for this order.
             *      */
            protocolFees: components["schemas"]["FeePolicy"][];
            /** @description A winning quote.
             *      */
            quote?: components["schemas"]["Quote"];
        };
        /** @description A batch auction for solving.
         *      */
        Auction: {
            /** @description The unique identifier of the auction. Increment whenever the backend creates a new auction.
             *      */
            id?: number;
            /** @description The block number for the auction. Orders and prices are guaranteed to be valid on this block. Proposed settlements should be valid for this block as well.
             *      */
            block?: number;
            /** @description The solvable orders included in the auction.
             *      */
            orders?: components["schemas"]["AuctionOrder"][];
            prices?: components["schemas"]["AuctionPrices"];
            /** @description List of addresses on whose surplus will count towards the objective value of their solution (unlike other orders that were created by the solver).
             *      */
            surplusCapturingJitOrderOwners?: components["schemas"]["Address"][];
        };
        /** @description The components that describe a batch auction for the solver competition.
         *      */
        CompetitionAuction: {
            /** @description The UIDs of the orders included in the auction.
             *      */
            orders?: components["schemas"]["UID"][];
            prices?: components["schemas"]["AuctionPrices"];
        };
        ExecutedAmounts: {
            sell: components["schemas"]["BigUint"];
            buy: components["schemas"]["BigUint"];
        };
        CompetitionOrderStatus: {
            /** @enum {string} */
            type: "open" | "scheduled" | "active" | "solved" | "executing" | "traded" | "cancelled";
            /** @description A list of solvers who participated in the latest competition, sorted
             *     by score in ascending order, where the last element is the winner.
             *
             *     The presence of executed amounts defines whether the solver provided
             *     a solution for the desired order. */
            value?: {
                /** @description Name of the solver. */
                solver: string;
                executedAmounts?: components["schemas"]["ExecutedAmounts"];
            }[];
        };
        /** @description The reference prices for all traded tokens in the auction as a mapping from token addresses to a price denominated in native token (i.e. 1e18 represents a token that trades one to one with the native token). These prices are used for solution competition for computing surplus and converting fees to native token.
         *      */
        AuctionPrices: {
            [key: string]: components["schemas"]["BigUint"] | undefined;
        };
        /** @description EIP-712 signature of struct OrderCancellations { orderUid: bytes[] } from the order's owner.
         *      */
        OrderCancellations: {
            /** @description UIDs of orders to cancel. */
            orderUids?: components["schemas"]["UID"][];
            /** @description `OrderCancellation` signed by the owner. */
            signature: components["schemas"]["EcdsaSignature"];
            signingScheme: components["schemas"]["EcdsaSigningScheme"];
        };
        /** @description [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signature of struct
         *     `OrderCancellation(bytes orderUid)` from the order's owner.
         *      */
        OrderCancellation: {
            /** @description OrderCancellation signed by owner */
            signature: components["schemas"]["EcdsaSignature"];
            signingScheme: components["schemas"]["EcdsaSigningScheme"];
        };
        /** @description Trade data such as executed amounts, fees, `orderUid` and `block` number.
         *      */
        Trade: {
            /** @description Block in which trade occurred. */
            blockNumber: number;
            /** @description Index in which transaction was included in block. */
            logIndex: number;
            /** @description UID of the order matched by this trade. */
            orderUid: components["schemas"]["UID"];
            /** @description Address of trader. */
            owner: components["schemas"]["Address"];
            /** @description Address of token sold. */
            sellToken: components["schemas"]["Address"];
            /** @description Address of token bought. */
            buyToken: components["schemas"]["Address"];
            /** @description Total amount of `sellToken` that has been executed for this trade (including fees). */
            sellAmount: components["schemas"]["TokenAmount"];
            /** @description The total amount of `sellToken` that has been executed for this order without fees. */
            sellAmountBeforeFees: components["schemas"]["BigUint"];
            /** @description Total amount of `buyToken` received in this trade. */
            buyAmount: components["schemas"]["TokenAmount"];
            /** @description Transaction hash of the corresponding settlement transaction containing the trade (if available). */
            txHash: components["schemas"]["TransactionHash"] | null;
            /** @description Executed protocol fees for this trade, together with the fee policies used. Listed in the order they got applied.
             *      */
            executedProtocolFees?: components["schemas"]["ExecutedProtocolFee"][];
        };
        /**
         * @description Unique identifier for the order: 56 bytes encoded as hex with `0x`
         *     prefix.
         *
         *     Bytes 0..32 are the order digest, bytes 30..52 the owner address and
         *     bytes 52..56 the expiry (`validTo`) as a `uint32` unix epoch timestamp.
         * @example 0xff2e2e54d178997f173266817c1e9ed6fee1a1aae4b43971c53b543cffcc2969845c6f5599fbb25dbdd1b9b013daf85c03f3c63763e4bc4a
         */
        UID: string;
        /**
         * @description How was the order signed?
         * @enum {string}
         */
        SigningScheme: "eip712" | "ethsign" | "presign" | "eip1271";
        /**
         * @description How was the order signed?
         * @enum {string}
         */
        EcdsaSigningScheme: "eip712" | "ethsign";
        /** @description A signature. */
        Signature: components["schemas"]["EcdsaSignature"] | components["schemas"]["PreSignature"];
        /**
         * @description 65 bytes encoded as hex with `0x` prefix. `r || s || v` from the spec.
         * @example 0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
         */
        EcdsaSignature: string;
        /**
         * @description Empty signature bytes. Used for "presign" signatures.
         * @example 0x
         */
        PreSignature: string;
        OrderPostError: {
            /** @enum {string} */
            errorType: "DuplicatedOrder" | "QuoteNotFound" | "QuoteNotVerified" | "InvalidQuote" | "MissingFrom" | "WrongOwner" | "InvalidEip1271Signature" | "InsufficientBalance" | "InsufficientAllowance" | "InvalidSignature" | "SellAmountOverflow" | "TransferSimulationFailed" | "ZeroAmount" | "IncompatibleSigningScheme" | "TooManyLimitOrders" | "TooMuchGas" | "UnsupportedBuyTokenDestination" | "UnsupportedSellTokenSource" | "UnsupportedOrderType" | "InsufficientValidTo" | "ExcessiveValidTo" | "InvalidNativeSellToken" | "SameBuyAndSellToken" | "UnsupportedToken" | "InvalidAppData" | "AppDataHashMismatch" | "AppDataMismatch" | "AppdataFromMismatch" | "MetadataSerializationFailed" | "OldOrderActivelyBidOn";
            description: string;
        };
        OrderCancellationError: {
            /** @enum {string} */
            errorType: "InvalidSignature" | "WrongOwner" | "OrderNotFound" | "AlreadyCancelled" | "OrderFullyExecuted" | "OrderExpired" | "OnChainOrder";
            description: string;
        };
        PriceEstimationError: {
            /** @enum {string} */
            errorType: "QuoteNotVerified" | "UnsupportedToken" | "NoLiquidity" | "UnsupportedOrderType";
            description: string;
        };
        /** @description The buy or sell side when quoting an order. */
        OrderQuoteSide: {
            kind: components["schemas"]["OrderQuoteSideKindSell"];
            /** @description The total amount that is available for the order. From this value, the fee is deducted and the buy amount is calculated.
             *      */
            sellAmountBeforeFee: components["schemas"]["TokenAmount"];
        } | {
            kind: components["schemas"]["OrderQuoteSideKindSell"];
            /** @description The `sellAmount` for the order. */
            sellAmountAfterFee: components["schemas"]["TokenAmount"];
        } | {
            kind: components["schemas"]["OrderQuoteSideKindBuy"];
            /** @description The `buyAmount` for the order. */
            buyAmountAfterFee: components["schemas"]["TokenAmount"];
        };
        /** @enum {string} */
        OrderQuoteSideKindSell: "sell";
        /** @enum {string} */
        OrderQuoteSideKindBuy: "buy";
        /** @description The validity for the order. */
        OrderQuoteValidity: {
            /** @description Unix timestamp (`uint32`) until which the order is valid. */
            validTo?: number;
        } | {
            /** @description Number (`uint32`) of seconds that the order should be valid for. */
            validFor?: number;
        };
        /** @description Request fee and price quote. */
        OrderQuoteRequest: components["schemas"]["OrderQuoteSide"] & components["schemas"]["OrderQuoteValidity"] & {
            /** @description ERC-20 token to be sold */
            sellToken: components["schemas"]["Address"];
            /** @description ERC-20 token to be bought */
            buyToken: components["schemas"]["Address"];
            /** @description An optional address to receive the proceeds of the trade instead of the
             *     `owner` (i.e. the order signer).
             *      */
            receiver?: components["schemas"]["Address"] | null;
            /** @description AppData which will be assigned to the order.
             *
             *     Expects either a string JSON doc as defined on
             *     [AppData](https://github.com/cowprotocol/app-data) or a hex
             *     encoded string for backwards compatibility.
             *
             *     When the first format is used, it's possible to provide the
             *     derived appDataHash field. */
            appData?: components["schemas"]["AppData"] | components["schemas"]["AppDataHash"];
            /** @description The hash of the stringified JSON appData doc.
             *
             *     If present, `appData` field must be set with the aforementioned
             *     data where this hash is derived from.
             *
             *     In case they differ, the call will fail. */
            appDataHash?: components["schemas"]["AppDataHash"];
            /** @default erc20 */
            sellTokenBalance: components["schemas"]["SellTokenSource"];
            /** @default erc20 */
            buyTokenBalance: components["schemas"]["BuyTokenDestination"];
            from: components["schemas"]["Address"];
            /** @default verified */
            priceQuality: components["schemas"]["PriceQuality"];
            /** @default eip712 */
            signingScheme: components["schemas"]["SigningScheme"];
            /**
             * @description Flag to signal whether the order is intended for on-chain order placement. Only valid for non ECDSA-signed orders."
             *
             * @default false
             */
            onchainOrder: unknown;
            /** @description User provided timeout in milliseconds. Can only be used to reduce the response time for quote requests if the default is too slow as values greater than the default will be capped to the default. Note that reducing the timeout can result in worse quotes because the reduced timeout might be too slow for some price estimators.
             *      */
            timeout?: number;
        };
        /** @description An order quoted by the backend that can be directly signed and
         *     submitted to the order creation backend.
         *      */
        OrderQuoteResponse: {
            /** @description The quoted order parameters. These values can be used directly to create and sign an order.
             *      */
            quote: components["schemas"]["OrderParameters"];
            /** @description The address of the trader for whom the quote was requested.
             *      */
            from?: components["schemas"]["Address"];
            /**
             * @description Expiration date of the offered fee. Order service might not accept
             *     the fee after this expiration date. Encoded as ISO 8601 UTC.
             *
             * @example 1985-03-10T18:35:18.814523Z
             */
            expiration: string;
            /** @description Quote ID linked to a quote to enable providing more metadata when analysing order slippage.
             *      */
            id?: number;
            /** @description Whether it was possible to verify that the quoted amounts are accurate using a simulation.
             *      */
            verified: boolean;
            /**
             * @description Protocol fee in basis points (e.g., "2" for 0.02%). This represents the volume-based fee policy. Only present when a volume fee is configured.
             *
             * @example 2
             */
            protocolFeeBps?: string;
        };
        /** @description The settlements submitted by every solver for a specific auction.
         *     The `auctionId` corresponds to the id external solvers are provided
         *     with.
         *      */
        SolverCompetitionResponse: {
            /** @description The ID of the auction the competition info is for. */
            auctionId?: number;
            /** @description Block that the auction started on. */
            auctionStartBlock?: number;
            /** @description Block deadline by which the auction must be settled. */
            auctionDeadlineBlock?: number;
            /** @description The hashes of the transactions for the winning solutions of this competition.
             *      */
            transactionHashes?: components["schemas"]["TransactionHash"][];
            /** @description The reference scores for each winning solver according to [CIP-67](https://forum.cow.fi/t/cip-67-moving-from-batch-auction-to-the-fair-combinatorial-auction/2967) (if available).
             *      */
            referenceScores?: {
                [key: string]: components["schemas"]["BigUint"] | undefined;
            };
            auction?: components["schemas"]["CompetitionAuction"];
            /** @description Maps from solver name to object describing that solver's settlement. */
            solutions?: components["schemas"]["SolverSettlement"][];
        };
        SolverSettlement: {
            /** @description Which position the solution achieved in the total ranking of the competition. */
            ranking?: number;
            /** @description The address used by the solver to execute the settlement on-chain.
             *
             *     This field is missing for old settlements, the zero address has been
             *     used instead. */
            solverAddress?: string;
            /** @description The score of the current auction as defined in [CIP-20](https://snapshot.org/#/cow.eth/proposal/0x2d3f9bd1ea72dca84b03e97dda3efc1f4a42a772c54bd2037e8b62e7d09a491f).
             *      */
            score?: components["schemas"]["BigUint"];
            /** @description The reference score as defined in [CIP-67](https://forum.cow.fi/t/cip-67-moving-from-batch-auction-to-the-fair-combinatorial-auction/2967) (if available).
             *      */
            referenceScore?: components["schemas"]["BigUint"] | null;
            /** @description Transaction in which the solution was executed onchain (if available).
             *      */
            txHash?: components["schemas"]["TransactionHash"] | null;
            /** @description The prices of tokens for settled user orders as passed to the settlement contract.
             *      */
            clearingPrices?: {
                [key: string]: components["schemas"]["BigUint"] | undefined;
            };
            /** @description Touched orders. */
            orders?: {
                id?: components["schemas"]["UID"];
                sellAmount?: components["schemas"]["BigUint"];
                buyAmount?: components["schemas"]["BigUint"];
            }[];
            /** @description whether the solution is a winner (received the right to get executed) or not */
            isWinner?: boolean;
            /** @description whether the solution was filtered out according to the rules of [CIP-67](https://forum.cow.fi/t/cip-67-moving-from-batch-auction-to-the-fair-combinatorial-auction/2967). */
            filteredOut?: boolean;
        };
        /** @description The estimated native price for the token
         *      */
        NativePriceResponse: {
            /** @description Estimated price of the token. */
            price?: number;
        };
        /** @description The total surplus.
         *      */
        TotalSurplus: {
            /** @description The total surplus. */
            totalSurplus?: string;
        };
        /** @description Represents a smart contract interaction that can be executed as part of an order's pre or post hooks.
         *      */
        InteractionData: {
            /** @description The address of the contract to call. */
            target: components["schemas"]["Address"];
            /** @description The amount of native token (ETH, xDAI, etc.) in Wei to send with the interaction call.
             *      */
            value: components["schemas"]["TokenAmount"];
            /** @description The calldata to be sent to the target contract. Encoded as a hex string with `0x` prefix.
             *      */
            callData: components["schemas"]["CallData"];
        };
        /** @description Quote data stored with an order. This represents the original quote used to
         *     create the order, containing gas estimation and pricing information captured
         *     at the time of quoting.
         *
         *     Note: This is different from `OrderQuoteResponse` which is returned by the
         *     `POST /api/v1/quote` endpoint and contains order parameters to sign.
         *      */
        StoredOrderQuote: {
            /**
             * @description The estimated gas units required to execute the quoted trade.
             *     Measured in gas units (not Wei). Used together with `gasPrice` and
             *     `sellTokenPrice` to calculate the network fee in sell token atoms.
             *
             * @example 150000
             */
            gasAmount: string;
            /**
             * @description The estimated gas price at the time of quoting, measured in Wei per gas unit.
             *     The network fee in Wei can be calculated as: `feeInWei = gasAmount * gasPrice`.
             *
             * @example 15000000000
             */
            gasPrice: string;
            /**
             * @description The price of the sell token expressed in native token atoms per sell token atom.
             *
             *     Units: `native token atoms / sell token atoms`
             *
             *     **Example calculation (Mainnet, selling USDC):**
             *     - Sell token: USDC (6 decimals)
             *     - Native token: ETH (18 decimals)
             *     - Market price: 1 ETH = 1000 USDC
             *
             *     `sellTokenPrice = 1  10^18 wei / (1000  10^6 USDC atoms) = 10^9`
             *
             *     This value is used to convert network fees (in native token) to sell token amounts.
             *
             * @example 1000000000
             */
            sellTokenPrice: string;
            /** @description The quoted sell amount in atoms of the sell token. */
            sellAmount: components["schemas"]["TokenAmount"];
            /** @description The quoted buy amount in atoms of the buy token. */
            buyAmount: components["schemas"]["TokenAmount"];
            /** @description The fee amount in atoms of the sell token, calculated from the gas parameters
             *     at the time of quoting.
             *
             *     Computed as: `ceil((gasAmount * gasPrice) / sellTokenPrice)`.
             *
             *     This represents the network fee that was estimated when the quote was created.
             *      */
            feeAmount: components["schemas"]["TokenAmount"];
            /** @description The address of the solver that provided this quote. */
            solver: components["schemas"]["Address"];
            /** @description Whether the quote was verified through simulation. A verified quote
             *     provides higher confidence that the trade will execute successfully.
             *      */
            verified: boolean;
            /** @description Additional metadata about the quote execution plan (e.g., the route taken).
             *     This field is only populated for orders that are no longer fillable
             *     (filled, cancelled, or expired) to prevent solvers from copying
             *     execution strategies for active orders.
             *      */
            metadata?: Record<string, never>;
        };
        /** @description A calculated order quote used in solver auctions.
         *      */
        Quote: {
            /** @description The amount of the sell token. */
            sellAmount?: components["schemas"]["TokenAmount"];
            /** @description The amount of the buy token. */
            buyAmount?: components["schemas"]["TokenAmount"];
            /** @description The amount that needs to be paid, denominated in the sell token. */
            fee?: components["schemas"]["TokenAmount"];
        };
        /** @description The protocol fee is taken as a percent of the surplus. */
        Surplus: {
            factor: number;
            maxVolumeFactor: number;
        };
        /** @description The protocol fee is taken as a percent of the order volume. */
        Volume: {
            factor: number;
        };
        /** @description The protocol fee is taken as a percent of the order price improvement which is a difference between the executed price and the best quote. */
        PriceImprovement: {
            factor: number;
            maxVolumeFactor: number;
            /** @description The best quote received. */
            quote: components["schemas"]["Quote"];
        };
        /** @description Defines the ways to calculate the protocol fee. */
        FeePolicy: components["schemas"]["Surplus"] | components["schemas"]["Volume"] | components["schemas"]["PriceImprovement"];
        ExecutedProtocolFee: {
            policy?: components["schemas"]["FeePolicy"];
            amount?: unknown & components["schemas"]["TokenAmount"];
            token?: unknown & components["schemas"]["Address"];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createOrder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The order to create. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrderCreation"];
            };
        };
        responses: {
            /** @description Order has been accepted. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UID"];
                };
            };
            /** @description Error during order validation. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrderPostError"];
                };
            };
            /** @description Forbidden, your account is deny-listed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No route was found quoting the order. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to parse request body as valid JSON. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many order placements. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error adding an order. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cancelOrders: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Signed `OrderCancellations`. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrderCancellations"];
            };
        };
        responses: {
            /** @description Order(s) are cancelled. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Malformed signature. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrderCancellationError"];
                };
            };
            /** @description Invalid signature. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description One or more orders were not found and no orders were cancelled. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to parse request body as valid JSON. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOrder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                UID: components["schemas"]["UID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Order */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Order"];
                };
            };
            /** @description Invalid order UID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Order was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cancelOrder: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                UID: components["schemas"]["UID"];
            };
            cookie?: never;
        };
        /** @description Signed `OrderCancellation` */
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrderCancellation"];
            };
        };
        responses: {
            /** @description Order cancelled. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Malformed signature. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrderCancellationError"];
                };
            };
            /** @description Invalid signature. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Order was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to parse request body as valid JSON. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOrderStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                UID: components["schemas"]["UID"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The order status with a list of solvers that proposed solutions (if applicable). */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CompetitionOrderStatus"];
                };
            };
            /** @description Invalid order UID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getOrdersByTxHash: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                txHash: components["schemas"]["TransactionHash"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Order(s). */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Order"][];
                };
            };
            /** @description Invalid transaction hash. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTrades: {
        parameters: {
            query?: {
                owner?: components["schemas"]["Address"];
                orderUid?: components["schemas"]["UID"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ### If `owner` is specified:
             *
             *     Return all trades related to that `owner`.
             *
             *     ### If `orderUid` is specified:
             *
             *     Return all trades related to that `orderUid`. Given that an order
             *     may be partially fillable, it is possible that an individual order
             *     may have *multiple* trades. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Trade"][];
                };
            };
        };
    };
    getTradesV2: {
        parameters: {
            query?: {
                owner?: components["schemas"]["Address"];
                orderUid?: components["schemas"]["UID"];
                /** @description The pagination offset. Defaults to 0.
                 *      */
                offset?: number;
                /** @description The maximum number of trades to return. Defaults to 10. Must be between 1 and 1000.
                 *      */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ### If `owner` is specified:
             *
             *     Return all trades related to that `owner`.
             *
             *     ### If `orderUid` is specified:
             *
             *     Return all trades related to that `orderUid`. Given that an order
             *     may be partially fillable, it is possible that an individual order
             *     may have *multiple* trades. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Trade"][];
                };
            };
        };
    };
    getCurrentBatchAuction: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Batch auction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Auction"];
                };
            };
        };
    };
    getUserOrdersPaginated: {
        parameters: {
            query?: {
                /** @description The pagination offset. Defaults to 0.
                 *      */
                offset?: number;
                /** @description The pagination limit. Defaults to 10. Maximum 1000. Minimum 1.
                 *      */
                limit?: number;
            };
            header?: never;
            path: {
                owner: components["schemas"]["Address"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The orders. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Order"][];
                };
            };
            /** @description Problem with parameters like limit being too large. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getTokenNativePrice: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                token: components["schemas"]["Address"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The estimated native price. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NativePriceResponse"];
                };
            };
            /** @description Error finding the price. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No liquidity was found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unexpected error. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    quote: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The order parameters to compute a quote for. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrderQuoteRequest"];
            };
        };
        responses: {
            /** @description Quoted order. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrderQuoteResponse"];
                };
            };
            /** @description Error quoting order. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PriceEstimationError"];
                };
            };
            /** @description No route was found for the specified order. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to parse request body as valid JSON. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too many order quotes. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unexpected error quoting an order. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSolverCompetitionByAuctionId: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                auction_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SolverCompetitionResponse"];
                };
            };
            /** @description Invalid auction ID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No competition information available for this auction id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSolverCompetitionByTxHash: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Transaction hash in which the competition was settled. */
                tx_hash: components["schemas"]["TransactionHash"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SolverCompetitionResponse"];
                };
            };
            /** @description Invalid transaction hash. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No competition information available for this `tx_hash`. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSolverCompetitionLatest: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SolverCompetitionResponse"];
                };
            };
            /** @description No competition information available. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSolverCompetitionByAuctionIdV2: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                auction_id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SolverCompetitionResponse"];
                };
            };
            /** @description Invalid auction ID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No competition information available for this auction id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSolverCompetitionByTxHashV2: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Transaction hash in which the competition was settled. */
                tx_hash: components["schemas"]["TransactionHash"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SolverCompetitionResponse"];
                };
            };
            /** @description Invalid transaction hash. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No competition information available for this `tx_hash`. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getSolverCompetitionLatestV2: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Competition */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SolverCompetitionResponse"];
                };
            };
            /** @description No competition information available. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getApiVersion: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Version */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/plain": unknown;
                };
            };
        };
    };
    getAppDataByHash: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                app_data_hash: components["schemas"]["AppDataHash"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Full `appData`. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppDataObject"];
                };
            };
            /** @description Invalid app data hash. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description No full `appData` stored for this hash. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    registerAppDataByHash: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                app_data_hash: components["schemas"]["AppDataHash"];
            };
            cookie?: never;
        };
        /** @description The `appData` document to upload. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AppDataObject"];
            };
        };
        responses: {
            /** @description The full `appData` already exists. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppDataHash"];
                };
            };
            /** @description The full `appData` was successfully registered. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppDataHash"];
                };
            };
            /** @description Error validating full `appData` */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to parse request body as valid JSON. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error storing the full `appData` */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    registerAppData: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The `appData` document to upload. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AppDataObject"];
            };
        };
        responses: {
            /** @description The full `appData` already exists. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppDataHash"];
                };
            };
            /** @description The full `appData` was successfully registered. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppDataHash"];
                };
            };
            /** @description Error validating full `appData` */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unable to parse request body as valid JSON. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error storing the full `appData` */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getAddressTotalSurplus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                address: components["schemas"]["Address"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The total surplus. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TotalSurplus"];
                };
            };
            /** @description Invalid address. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
